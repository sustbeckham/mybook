## 实战V1

改编(参考):
https://juejin.im/post/5c16471f6fb9a049c43d91d4

### 一面(侧重点: 技术广度, 同时结合项目死扣各种细节以及技术深度)

1. 介绍自己参与度最高的项目

   雷蛇。
   
2. 项目有多大的并发量?

   平时QPS大约在5-10之间。大促峰值约在500-1000之间。     

3. 说说具体的业务, 然后画一下系统架构图。

4. 请求具体落在哪些接口上?

5. 哪些数据是数据库和缓存双写一份的(这里可能要问为什么不用redis来扣减库存)?

   目前是库存的

6. 紧跟5, 双写一致性如何保证？保证一致性的同时如何保证高并发和性能?

7. 缓存线上是如何部署的? 给了多大的内存(可能会问为什么要这么多内存, 即怎么算的)? 命中率有多高? 

8. 缓存扛了多少QPS? 数据流回源会有多少QPS?

9. 集群中是否某个key出现了热点缓存导致缓存集群中某个机器的负载过高? 如何解决的?

10. 是否出现超大value打满网卡的问题? 如何规避?

11. 线上是否出现过缓存集群事故? 如果出现了你们怎么解决有什么高可用的保障方案么？

12. 平时如何监控缓存集群的QPS和容量? 如果要扩容该怎么扩容? 能否平滑扩容? 扩容会导致系统需要停机吗?

13. 聊聊Redis的集群原理? 扩容的时候会不会导致丢数据? key寻址算法都了解哪些?

14. 了解一致性哈希算法吗? 画图说说redis线程模型和内存模型?

15. 连珠炮之MQ
    参考: https://doocs.github.io/advanced-java/#/./docs/high-concurrency/mq-interview
    A. 为什么使用消息队列? 以及消息队列的选型(kafka, ActiveMQ, RabbitMQ, RocketMQ)? 
       参考: https://juejin.im/post/5c0fbaf8f265da616f6fd0c3
       首先是选型。
           ActiveMQ是老牌的消息中间件, 但是目前在国内用来支撑互联网的高并发应用的案例较少, 现在多用于传统项目进行业务解耦。
           RabbitMQ很好, 社区活跃, 迭代迅速，性能突出，功能完善。但是! 它是用Erlang开发的, 导致源码难以分析, 如果要排查问题和二次扩展,
           会比较麻烦, 毕竟国内对于Erlang精通的人并不多
           RocketMQ, BABA出品, 经过了双11的历年大考, 性能很好也是apache的顶级项目了。还支持分布式事务等特性。语言基于Java, 适合二次扩展。
           但是周边生态明显要弱一些。
           kafka和RabbitMQ类似。社区活跃, 迭代迅速，性能突出，功能完善。且kafka是基于Scala的。同时kafka的对于大数据生态的支持比较好。
           比如现在kafka的版本升级大部分都是偏向于kafka-stream的改进。
           但是更重要的一点是要注意你们公司当前是否有专门的团队维护已知的消息中间件。
       为什么使用说了很多次了:
           削峰, 解耦, 异步。     
              
    B. 使用消息队列的优点和缺点? 
       参考: https://juejin.im/post/5c1214a66fb9a049bb7c3410
       换个问法就是: 引入消息中间件有什么缺点?(优点可以囊括在上边的为什么使用中) 
       A. 可用性可能降低
          多引入了一个组件, 就必须考虑这个组件crash的可能性, 进一步需要考虑它的部署方式, 才能保证整个服务的可用性。甚至于要考虑如果MQ
          挂掉, 应用该如何运行。
       B. 稳定性可能降低
          比如MQ就是出了bug丢了消息, 消息重复(当然我们通过自身幂等可以解决), 即可能增加额外的故障来源
       C. 分布式环境的一致性问题
          比如MQ消息因为网络问题到达broker或者从broker发出延迟会导致数据不一致。
       
    C. 如何保证消息队列的高可用(本质上在问消息中间件的部署模型)?
        参考:
        https://www.infoq.cn/article/kafka-analysis-part-2/  (重点)
        https://www.infoq.cn/article/kafka-analysis-part-3
        这里着重描述下kafka的高可用即可。
        A. 首先尽量将toic的partition均匀的分配到整个集群, 也需要将partition的replica分散到整个集群(如果replica在单机挂了就完了)。
        B. Producer的读写都是通过leader来进行(通过zk来获取leader)。Leader写入数据后, Follower从Leader去pull数据, Follower收到消息
           并写入后向Leader发送ACK, Leader收到所有ISR的Replica的ACK则认为消息commit并会向Producer发送ACK.
        C. B描述的其实是一种严格的情况。通过request.required.acks, Producer可以选择不care是否发送成功、发送Leader成功、Leader和
           Follower都成功3种模式。不同情况下耗时依次递增, 可用性依次增强。
        D. Kafka0.8有个问题是Follower如果复制了数据到内存就返回ACK了, 加快了速度。但是如果断电就傻逼了。暂时该问题没修复。   
        E. consumer只能消费到被所有ISR同步的消息。    
        F. Leader选举kafka没有采用常见的"MajorityVote"(少数服从多数), 原因是会有大量的资源浪费。比如要融入3个Follower挂掉, 必须要7
           个以上的Replica。而大量的Replica在大数据量下又会导致性能下降。所以ZK这种配置系统可以用少数服从多数, 但是大数据量下不适合。
        G. 实际的Leader选举大部分情况比较随意, 就是在AR里边选第一个(但是必须存在于ISR)   
        H. 实施Leader选举的是Controller(其实也是Broker), 在启动时通过watch目录(基于ZK)选定
    
    D. 如何保证消息的可靠性传输? 要是消息丢失了怎么办?(其实在问中间件的设计)
       在C中有提及。
       request.required.acks=0.代表不关心Leader的响应。网络异常时就会丢消息。
       request.required.acks=1,代表Leader接受成功返回消息, 但是如果这个时候Leader嗝屁了(Follower还没拉走消息)。消息就丢了。
       request.required.acks=-1(all),代表Leader和ISR都接收才返回ACK。不会丢消息, 但是性能最差。
    
    E. 如何保证消息的顺序性?(其实还在问中间件的设计)
    F. 如何解决消息队列的延时以及过期失效问题? 消息队列满了以后该怎么处理? 有几百万消息持续积压几个小时该怎么解决? (这个问题貌似遇见的比较少)
    G. 如果自己实现一个消息队列, 该如何进行架构设计? 说一下思路

16. 连珠炮之MySQL分库分表

17. 连珠炮之高可用

18. 连珠炮之多线程

19. 连珠炮之JVM

### 二面(侧重点: 技术深度, 系统设计, 工程素养, 带团队)

1. redis内核, redis数据结构和实现原理

2. redis集群, 哨兵, 持久化

3. kafka故障转移(KafkaController)

4. kafka日志存储

5. kafka网络通信

6. kafka磁盘读写高性能, zero-copy

7. kafka的leader-follower之间数据同步

8. dubbo源码

9. 给出具体的用户量业务量场景, 线程画出架构设计图(系统设计，彪子之前碰到过)

10. 如何做技术设计, 技术评审, 编码规范, 测试, 上线, 回滚, 灰度, 压测, 监控等(工程素养)

11. 如何招人, 藐视标准, 如何搭建团队的人才梯度(带团队)

12. 架构演进(比如淘宝十年那本书描述的), 0-1的架构, 1-10的架构，10-1000的架构? 考察整体架构能力以及技术规划能力
    参考: https://doocs.github.io/advanced-java/#/./docs/high-concurrency/high-concurrency-design
    可以换一个方式问: 如何设计一个高并发系统?
    A. 服务拆分, 大服务拆分为逻辑独立的小服务。多个服务多个应用集群多个DB实例, 流量分散。
    B. 缓存(分布式缓存+本地缓存)。缓存主要应对大量的读操作, 避免打爆DB. 同时如果可以尽量有单独的分布式缓存集群。避免干扰。
    C. MQ(异步,削峰,解耦)。主要考量是异步的写提升消费者整体性能。
    D. 分库分表(DB层面)。建立在服务拆分后子服务DB或者单表依然顶不住的case。分库提升子应用整体性能
    E. 读写分离(DB层面)。还是在讨论DB撑不住的问题。将读操作切换到备库, 分摊压力。
    F. 查询接入搜索引擎。一是提升了查询性能, 而是环境DB的读压力。
    
    在以上, 更重要的是要考虑哪些表需要分库分表。单库单表和分库分表如何做join(这种最好禁止)。什么样的数据
    需要放入cache等。即对于应用整体业务细节的把控。
   

### 三面(侧重点:公司经历, 项目经验)

1. 具体负责过哪些比较有挑战的大型的系统?

2. 软实力考察(责任心, 抗压能力, 自我驱动力), 自己举例证明

3. 聊聊职业价值观, 是否愿意加班等。

### 终面(侧重点:HR)

1. 做过最难的事情是啥, 如何克服? 当时什么心态?

2. 为什么要离职？没有发展空间? 为什么不考虑现有公司内部转岗?

3. 自己的历史绩效如何? 和同事相处如何？